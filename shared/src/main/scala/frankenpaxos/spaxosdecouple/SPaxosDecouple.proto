syntax = "proto2";

package frankenpaxos.spaxosdecouple;

import "scalapb/scalapb.proto";

option (scalapb.options) = {
  package_name: "frankenpaxos.spaxosdecouple"
  flat_package: true
};


// Helper messages. ////////////////////////////////////////////////////////////
// Every instance is of the form `leader_index.instance_number` where
// `leader_index` is the unique index of the leader and `instance_number` is a
// monotonically increasing integer. In the EPaxos paper, for example, these
// are written like R.1 or Q.2.
message Instance {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 replica_index = 1;
  required int32 instance_number = 2;
}

// Every ballot has the form `ordering.replica_index` where `ordering` is a
// monotonically increasing integer and `replica_index` is the unique index of
// the replica.
message Ballot {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 ordering = 1;
  required int32 replica_index = 2;
}

// A special noop command that does not affect the state machine.
message Noop {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";
}

// A client issued command.
message Command {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required UniqueId command_id = 1;
  required bytes command = 2;
}

message UniqueId {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  // The client's address.
  required bytes client_address = 1;

  // Clients use pseudonyms to simulate multiple clients. See Fast MultiPaxos
  // for more explanation.
  required int32 client_pseudonym = 2;

  // Clients annotate every command with a unique and monotonically increasing
  // id. The pair of (client address, client id) uniquely identify a command.
  required int32 client_id = 3;
}

message CommandOrNoop {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof value {
    Command command = 1;
    Noop noop = 2;
  }
}

// TODO(mwhittaker): Do we need all these statuses?
enum CommandStatus {
  NotSeen = 0;
  PreAccepted = 1;
  Accepted = 2;
}

// Protocol messages. //////////////////////////////////////////////////////////
message ClientRequest {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required UniqueId unique_id = 1;
  required bytes command = 2;
}

message Forward {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required RequestBatch request_batch = 1;
  required BatchId batch_id = 2;
  required int32 proposer_index = 3;
}

message Acknowledge {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required CommandBatch command_batch = 1;
}

message Decide {
  // The index of the log for the command
  required int32 slot = 1;

  required UniqueId unique_id = 2;
}

// The designated "any" value.
message AnyVal {}

// An infinite suffix of any's. See Phase2a.
message AnyValSuffix {}

message Phase1a {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;

  // The leader knows that all entries in slots less than `chosenWatermark`
  // have been chosen. Acceptors do not have to include slots below
  // `chosenWatermark` in their phase1b response.
  //
  // The leader may know that some entries larger than `chosenWatermark` have
  // also been chosen, but that's okay. It's not unsafe for acceptors to return
  // too much information.
  required int32 chosen_watermark = 2;
}

message Phase1bSlotInfo {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required int32 vote_round = 2;
  required CommandBatchOrNoop vote_value = 3;
}

message Phase1b {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 group_index = 1;
  required int32 acceptor_index = 2;
  required int32 round = 3;
  repeated Phase1bSlotInfo info = 4;
}

message Phase2a {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required int32 round = 2;
  required CommandBatchOrNoop command_batch_or_noop = 3;
}

message Phase2b {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 acceptor_index = 1;
  required int32 slot = 2;
  required int32 round = 3;
}

message ValueChosen {
  required int32 slot = 1;
  required CommandBatchOrNoop command_batch_or_noop = 2;
}

message ValueChosenBuffer {
  repeated ValueChosen value_chosen = 1;
}

message ClientReply {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required UniqueId unique_id = 1;
  // The result of executing the command.
  required bytes result = 2;
}

message Proposal {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required UniqueId unique_id = 1;
  required int32 round = 2;
}

message LeaderInfo {
  required int32 round = 1;
}

message BatchId {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required string batch_id = 1;
}

message CommandBatch {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required BatchId batch_id = 1;
}

message CommandBatchOrNoop {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  oneof value {
    CommandBatch command_batch = 1;
    Noop noop = 2;
  }
}

message RequestBatchOrNoop {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  oneof value {
    RequestBatch command_batch = 1;
    Noop noop = 2;
  }
}

message Chosen {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  required int32 slot = 1;
  required RequestBatchOrNoop command_batch_or_noop = 2;
}

message RequestBatch {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";
  repeated ClientRequest batch = 1;
}

message ClientRequestBatch {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required CommandBatch command_batch = 1;
}

message ClientReplyBatch {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  repeated ClientReply batch = 1;
}

message NotLeaderClient {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";
}

message LeaderInfoReplyClient {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
}

message ChosenWatermark {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  // Replicas periodically send ChosenWatermark messages to the leaders
  // informing them that every log entry smaller than `slot` has been chosen.
  // For example, if `slot` is 3, then slots 0, 1, and 2 have been chosen.
  // Slots above `slot` may also be chosen, but that's okay.
  //
  // If replicas didn't send these messages, then leaders would have no idea
  // which commands have been chosen and which haven't. This can significantly
  // slow things down after a leader change.
  required int32 slot = 1;
}

message Recover {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  // Replicas execute logs in prefix order. Thus, if the log permanently has a
  // hole in it, the algorithm remains forever blocked. To solve this, if a
  // replica notices a hole in its log for a certain amount of time, it sends a
  // Recover message to the leader to get the hole plugged.
  required int32 slot = 1;
}

message NotLeaderBatcher {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required ClientRequestBatch client_request_batch = 1;
}

message LeaderInfoRequestBatcher {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";
}

message LeaderInfoReplyBatcher {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
}

message LeaderInfoRequestClient {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";
}

message Nack {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  required int32 round = 1;
}

// Inbound messages. ///////////////////////////////////////////////////////////
message ProposerInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    ClientRequest client_request = 1;
    Acknowledge acknowledge = 2;
    LeaderInfo leader_info = 3;
    RequestBatch request_batch = 4;
  }
}

message BatcherInbound {
  option (scalapb.message).annotations =
         "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    ClientRequest client_request = 1;
    NotLeaderBatcher not_leader_batcher = 2;
    LeaderInfoReplyBatcher leader_info_reply_batcher = 3;
  }
}

message LeaderInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    Phase1b phase1b = 1;
    ClientRequest client_request = 2;
    ClientRequestBatch client_request_batch = 3;
    LeaderInfoRequestClient leader_info_request_client = 4;
    LeaderInfoRequestBatcher leader_info_request_batcher = 5;
    Nack nack = 6;
    ChosenWatermark chosen_watermark = 7;
    Recover recover = 8;
  }
}

message AcceptorInbound {
  oneof request {
    Phase1a phase1a = 1;
    Phase2a phase2a = 2;
  }
}

message ExecutorInbound {
  oneof request {
    ValueChosen value_chosen = 1;
    ValueChosenBuffer value_chosen_buffer = 2;
    Forward forward = 3;
  }
}

message DisseminatorInbound {
  oneof request {
    ValueChosen value_chosen = 1;
    Forward forward = 2;
  }
}

message ClientInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    ClientReply client_reply = 1;
    NotLeaderClient not_leader_client = 2;
    LeaderInfoReplyClient leader_info_reply_client = 3;
  }
}

message ProxyLeaderInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    Phase2a phase2a = 1;
    Phase2b phase2b = 2;
  }
}

message ReplicaInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    Chosen chosen = 1;
  }
}

message ProxyReplicaInbound {
  option (scalapb.message).annotations =
    "@scala.scalajs.js.annotation.JSExportAll";

  oneof request {
    ClientReplyBatch client_reply_batch = 1;
    ChosenWatermark chosen_watermark = 2;
    Recover recover = 3;
  }
}
